<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tile-Based Emoji Quest: Phaser 3 Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #4CAF50;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }
        .game-container {
            width: 90vw;
            max-width: 800px;
            background-color: #2E7D32;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            margin-top: 0;
        }
        .game-border {
            border: 5px solid #1B5E20;
            border-radius: 10px;
            overflow: hidden;
            aspect-ratio: 1 / 1;
        }
        #game-canvas {
            width: 100%;
            height: 100%;
        }
        .game-info {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
        }
        .game-info div {
            flex: 1;
            padding: 10px;
            background-color: #1B5E20;
            border-radius: 5px;
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Tile-Based Emoji Quest</h1>
        <div class="game-border">
            <div id="game-canvas"></div>
        </div>
        <div class="game-info">
            <div id="story">Welcome to Tile-Based Emoji Quest!</div>
            <div id="inventory">Inventory: Empty</div>
        </div>
    </div>
    <script>
        const MAP_WIDTH = 10;
        const MAP_HEIGHT = 10;

        const PLAYER = 'üê±';
        const WALL = 'üå≥';
        const GRASS = 'üü©';
        const WEAPON = 'üó°Ô∏è';
        const MONSTER = 'üëæ';
        const FAIRY = 'üßö';
        const CASTLE = 'üè∞';

        let player, monster, fairy, castle;
        let walls, weapons;
        let cursors;
        let map = [];
        let inventory = [];
        let isMonsterDefeated = false;
        let isFairyCaptured = false;
        let canMove = true;

        const config = {
            type: Phaser.AUTO,
            parent: 'game-canvas',
            backgroundColor: '#9CCC65',
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH,
                width: MAP_WIDTH * 60,
                height: MAP_HEIGHT * 60
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        const game = new Phaser.Game(config);

        function preload() {
            // No preload needed for this version
        }

        function create() {
            this.add.rectangle(0, 0, config.scale.width, config.scale.height, 0x9CCC65).setOrigin(0);
            
            const tileSize = config.scale.width / MAP_WIDTH;
            
            generateMap(this, tileSize);
            cursors = this.input.keyboard.createCursorKeys();

            // Add touch input for mobile devices
            this.input.on('pointerdown', function (pointer) {
                const touchX = Math.floor(pointer.x / tileSize);
                const touchY = Math.floor(pointer.y / tileSize);
                handleTouchInput(touchX, touchY);
            });
        }

        function generateMap(scene, tileSize) {
            walls = scene.add.group();
            weapons = scene.add.group();

            for (let y = 0; y < MAP_HEIGHT; y++) {
                map[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    map[y][x] = GRASS;
                    scene.add.text(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, GRASS, { fontSize: `${tileSize * 0.7}px` }).setOrigin(0.5);
                }
            }

            placeElements(scene, walls, WALL, 15, tileSize);
            placeElements(scene, weapons, WEAPON, 1, tileSize);

            castle = createEmojiSprite(scene, Phaser.Math.Between(0, MAP_WIDTH - 1), Phaser.Math.Between(0, MAP_HEIGHT - 1), CASTLE, tileSize);
            player = createEmojiSprite(scene, Phaser.Math.Between(0, MAP_WIDTH - 1), Phaser.Math.Between(0, MAP_HEIGHT - 1), PLAYER, tileSize);
            monster = createEmojiSprite(scene, Phaser.Math.Between(0, MAP_WIDTH - 1), Phaser.Math.Between(0, MAP_HEIGHT - 1), MONSTER, tileSize);
            fairy = createEmojiSprite(scene, Phaser.Math.Between(0, MAP_WIDTH - 1), Phaser.Math.Between(0, MAP_HEIGHT - 1), FAIRY, tileSize);
        }

        function createEmojiSprite(scene, x, y, emoji, tileSize) {
            const text = scene.add.text(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, emoji, { fontSize: `${tileSize * 0.7}px` }).setOrigin(0.5);
            text.gridX = x;
            text.gridY = y;
            return text;
        }

        function placeElements(scene, group, emoji, count, tileSize) {
            for (let i = 0; i < count; i++) {
                let x, y;
                do {
                    x = Phaser.Math.Between(0, MAP_WIDTH - 1);
                    y = Phaser.Math.Between(0, MAP_HEIGHT - 1);
                } while (map[y][x] !== GRASS);
                map[y][x] = emoji;
                const element = scene.add.text(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, emoji, { fontSize: `${tileSize * 0.7}px` }).setOrigin(0.5);
                element.gridX = x;
                element.gridY = y;
                group.add(element);
            }
        }

        function update() {
            if (!canMove) return;

            let dx = 0;
            let dy = 0;

            if (cursors.left.isDown) {
                dx = -1;
            } else if (cursors.right.isDown) {
                dx = 1;
            } else if (cursors.up.isDown) {
                dy = -1;
            } else if (cursors.down.isDown) {
                dy = 1;
            }

            if (dx !== 0 || dy !== 0) {
                movePlayer(player.gridX + dx, player.gridY + dy);
            }
        }

        function handleTouchInput(touchX, touchY) {
            if (!canMove) return;

            const dx = touchX - player.gridX;
            const dy = touchY - player.gridY;

            // Determine the primary and secondary directions
            let primaryDir, secondaryDir;
            if (Math.abs(dx) > Math.abs(dy)) {
                primaryDir = { x: Math.sign(dx), y: 0 };
                secondaryDir = { x: 0, y: Math.sign(dy) };
            } else {
                primaryDir = { x: 0, y: Math.sign(dy) };
                secondaryDir = { x: Math.sign(dx), y: 0 };
            }

            // Try to move in the primary direction
            if (canMoveTo(player.gridX + primaryDir.x, player.gridY + primaryDir.y)) {
                movePlayer(player.gridX + primaryDir.x, player.gridY + primaryDir.y);
            }
            // If can't move in primary direction, try secondary
            else if (canMoveTo(player.gridX + secondaryDir.x, player.gridY + secondaryDir.y)) {
                movePlayer(player.gridX + secondaryDir.x, player.gridY + secondaryDir.y);
            }
            // If both fail, don't move
        }

        function canMoveTo(x, y) {
            return x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT && map[y][x] !== WALL;
        }

        function movePlayer(newX, newY) {
            if (!canMoveTo(newX, newY)) return;

            canMove = false;
            const oldX = player.gridX;
            const oldY = player.gridY;
            player.gridX = newX;
            player.gridY = newY;
            
            const tileSize = config.scale.width / MAP_WIDTH;
            const duration = 200; // Animation duration in milliseconds

            player.scene.tweens.add({
                targets: player,
                x: newX * tileSize + tileSize / 2,
                y: newY * tileSize + tileSize / 2,
                duration: duration,
                ease: 'Linear',
                onComplete: () => {
                    checkCollisions();
                    moveMonster();
                    moveFairy();
                    canMove = true;
                }
            });
        }

        function moveCharacter(character, newX, newY) {
            const tileSize = config.scale.width / MAP_WIDTH;
            const duration = 200; // Animation duration in milliseconds

            character.scene.tweens.add({
                targets: character,
                x: newX * tileSize + tileSize / 2,
                y: newY * tileSize + tileSize / 2,
                duration: duration,
                ease: 'Linear'
            });

            character.gridX = newX;
            character.gridY = newY;
        }

        function checkCollisions() {
            if (player.gridX === monster.gridX && player.gridY === monster.gridY) {
                fightMonster();
            }
            if (player.gridX === fairy.gridX && player.gridY === fairy.gridY) {
                captureFairy();
            }
            if (player.gridX === castle.gridX && player.gridY === castle.gridY) {
                enterCastle();
            }

            weapons.children.entries.forEach(weapon => {
                if (player.gridX === weapon.gridX && player.gridY === weapon.gridY) {
                    collectWeapon(weapon);
                }
            });
        }

        function moveMonster() {
            if (!isMonsterDefeated) {
                const dx = Phaser.Math.Clamp(player.gridX - monster.gridX, -1, 1);
                const dy = Phaser.Math.Clamp(player.gridY - monster.gridY, -1, 1);
                
                if (canMoveTo(monster.gridX + dx, monster.gridY + dy)) {
                    moveCharacter(monster, monster.gridX + dx, monster.gridY + dy);
                }
            }
        }

        function moveFairy() {
            if (!isFairyCaptured) {
                const dx = Phaser.Math.Clamp(monster.gridX - fairy.gridX, -1, 1);
                const dy = Phaser.Math.Clamp(monster.gridY - fairy.gridY, -1, 1);
                
                if (canMoveTo(fairy.gridX + dx, fairy.gridY + dy)) {
                    moveCharacter(fairy, fairy.gridX + dx, fairy.gridY + dy);
                }
            }
        }

        function collectWeapon(weapon) {
            weapon.destroy();
            inventory.push(WEAPON);
            updateInventory();
            updateStory("You found a weapon! Now you can face the monster!");
        }

        function fightMonster() {
            if (inventory.includes(WEAPON) && !isMonsterDefeated) {
                monster.destroy();
                isMonsterDefeated = true;
                inventory = inventory.filter(item => item !== WEAPON);
                updateInventory();
                updateStory("You defeated the monster! Now capture the fairy and reach the castle!");
            } else if (!isMonsterDefeated) {
                updateStory("Oh no! The monster caught you. Game Over!");
                setTimeout(() => { location.reload(); }, 2000);
            }
        }

        function captureFairy() {
            fairy.destroy();
            isFairyCaptured = true;
            updateStory("You captured the fairy! Now reach the castle to win!");
        }

        function enterCastle() {
            if (isMonsterDefeated && isFairyCaptured) {
                updateStory("Congratulations! You've completed your quest!");
                canMove = false;
            } else {
                let message = "You need to ";
                if (!isMonsterDefeated) message += "defeat the monster ";
                if (!isMonsterDefeated && !isFairyCaptured) message += "and ";
                if (!isFairyCaptured) message += "capture the fairy ";
                message += "before entering the castle!";
                updateStory(message);
            }
        }

        function updateStory(message) {
            document.getElementById('story').textContent = message;
        }

        function updateInventory() {
            document.getElementById('inventory').textContent = 'Inventory: ' + (inventory.length > 0 ? inventory.join(', ') : 'Empty');
        }
    </script>
</body>
</html>